import json
import argparse
import os
from libraries.output_files import output,output_secstr
from libraries.output_files_below_the_threshold import output_below_t
from libraries.interactions import canonical_pairs, other_pairs, base_phosphate, phosphate_base,\
    stacking_1, stacking_2, stacking_3, stacking_4
from libraries.interactions_below_the_threshold import canonical_pairs_below_t, other_pairs_below_t,\
    base_phosphate_below_t, phosphate_base_below_t, stacking_1_below_t, stacking_2_below_t, stacking_3_below_t,\
    stacking_4_below_t

cwd = os.getcwd()

'''
A program to parse a json file generated by ClaRNA to extract interactions.

Usage:
clarna_json_parser.py --file=filename  --threshold=threshold

Example usage:
python3 clarna_json_parser.py -f sample_input.json

'''
#parser = argparse.ArgumentParser()
parser = argparse.ArgumentParser(description='A program to parse a json file generated by ClaRNA to extract interactions')
parser.add_argument('-f', action='store', help ='your input file (a json file generated by ClaRNA)')
parser.add_argument('-t', action='store', help ='your preferred threshold (the default value is 0.5)')
args = parser.parse_args()

if args.t !=None:
    threshold = float(args.t)
else:
    threshold = 0.5

f= open(args.f,'r')

content = json.load(f)

#******************************************
input_file_name = args.f.split('/')[-1].split('.')[0]
log = open(cwd + '/' + input_file_name + '.log', 'w')
log.write('Threshold: ' + str(threshold) + '\n' )

#******************************************
# Extract the sequence from the json file.
def sequence():
    residue={}
    for a in range(len(content['nodes'])):
        if any(c in 'AUGC' for c in content['nodes'][a]['resname']) and len(content['nodes'][a]['resname'])==1:
            residue[a] = [content['nodes'][a], int(content['nodes'][a]['id'][1:])]

    sorted_residue = sorted(residue.items(), key=lambda item: item[1][1])

    log.write('Sequence is extracting... ')
    return sorted_residue

sorted_residue = sequence()
log.write('Done.\n')

#******************************************
# Call the functions of interactions
total_canonical = canonical_pairs(sorted_residue, content, threshold, log)
consensus = ''
consensus_canonical = consensus
log.write('Done.\n')

total_other_pairs = other_pairs(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_base_phosphate = base_phosphate(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_phosphate_base = phosphate_base(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_1 = stacking_1(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_2 = stacking_2(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_3= stacking_3(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_4 = stacking_4(sorted_residue, content, threshold, log)
log.write('Done.\n')

#******************************************
# Call the functions of interactions below the threshold
total_canonical_below_t= canonical_pairs_below_t(sorted_residue, content, threshold, log)
consensus_below_t = ''
consensus_canonical_below_t = consensus_below_t
log.write('Done.\n')

total_other_pairs_below_t = other_pairs_below_t(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_base_phosphate_below_t = base_phosphate_below_t(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_phosphate_base_below_t = phosphate_base_below_t(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_1_below_t = stacking_1_below_t(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_2_below_t = stacking_2_below_t(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_3_below_t= stacking_3_below_t(sorted_residue, content, threshold, log)
log.write('Done.\n')

total_stacking_4_below_t = stacking_4_below_t(sorted_residue, content, threshold, log)
log.write('Done.\n')

#******************************************
# A dictionary of "all_interactions".
all_interactions ={}
if sorted_residue != {}:
    all_interactions['sequence'] = sorted_residue
if total_canonical != {}:
    all_interactions['canonical'] = total_canonical
if consensus_canonical != {}:
    all_interactions['consensus'] = consensus
if total_other_pairs != {}:
    all_interactions['other_pairs'] = total_other_pairs
if total_base_phosphate != {}:
    all_interactions['base_phosphate'] = total_base_phosphate
if total_phosphate_base != {}:
    all_interactions['phosphate_base'] = total_phosphate_base
if total_stacking_1 != {}:
    all_interactions['stacking_1'] = total_stacking_1
if total_stacking_2 != {}:
    all_interactions['stacking_2'] = total_stacking_2
if total_stacking_3 != {}:
    all_interactions['stacking_3'] = total_stacking_3
if total_stacking_4 != {}:
    all_interactions['stacking_4'] = total_stacking_4

#******************************************
# A dictionary of "all_interactions below the threshold".
all_interactions_below_t ={}
if sorted_residue != {}:
    all_interactions_below_t['sequence'] = sorted_residue
if total_canonical_below_t != {}:
    all_interactions_below_t['canonical'] = total_canonical_below_t
if consensus_below_t != {}:
    all_interactions_below_t['consensus'] = consensus_below_t
if total_other_pairs_below_t != {}:
    all_interactions_below_t['other_pairs'] = total_other_pairs_below_t
if total_base_phosphate_below_t != {}:
    all_interactions_below_t['base_phosphate'] = total_base_phosphate_below_t
if total_phosphate_base_below_t != {}:
    all_interactions_below_t['phosphate_base'] = total_phosphate_base_below_t
if total_stacking_1_below_t != {}:
    all_interactions_below_t['stacking_1'] = total_stacking_1_below_t
if total_stacking_2_below_t != {}:
    all_interactions_below_t['stacking_2'] = total_stacking_2_below_t
if total_stacking_3_below_t != {}:
    all_interactions_below_t['stacking_3'] = total_stacking_3_below_t
if total_stacking_4_below_t != {}:
    all_interactions_below_t['stacking_4'] = total_stacking_4_below_t

#******************************************
# Calling output function to write interactions
out = open(cwd + '/' + input_file_name + '.json.clarna.txt', 'w')
output(all_interactions, input_file_name, out, log)
output_below_t(all_interactions_below_t, input_file_name, out, log)

#******************************************
# Run Michal's consensus program on '.SS' file with a consensus threshold of 0.1
wd = os.path.dirname(__file__)
if wd != '':
    # For mac os:
    #cmd = 'noah ' + wd +'/SS_consensus/find_SS_consensus ' + cwd + '/' + input_file_name + '.SS 0.1 > ' + cwd + '/' + input_file_name + '.CS'
    # For Linux os:
    cmd = wd +'/SS_consensus/find_SS_consensus ' + cwd + '/' + input_file_name + '.SS 0.1 > ' + cwd + '/' + input_file_name + '.CS'

else:
    # For mac os:
    #cmd = 'noah ' + cwd + '/SS_consensus/find_SS_consensus ' + cwd + '/' + input_file_name + '.SS 0.1 > ' + cwd + '/' + input_file_name + '.CS'
    # For Linux os:
    cmd = cwd +'/SS_consensus/find_SS_consensus '+ cwd + '/' + input_file_name + '.SS 0.1 > ' + cwd + '/' + input_file_name + '.CS'

os.system(cmd)

#******************************************
# Pars the output of Michal's consensus program.
csfile = open(cwd + '/' + input_file_name + '.CS', 'r')
css = csfile.readlines()
for cs in range(len(css)):
    if css[cs].strip() == '>consensus_pairs_unique_single_line':
        consensus = css[cs+1].strip()
all_interactions['consensus'] = consensus

#******************************************
# Calling output_secstr function to write consensus
output_secstr(all_interactions,input_file_name, log)



